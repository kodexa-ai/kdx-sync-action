name: 'Kodexa Sync'
description: 'GitOps deployment for Kodexa metadata - branch mappings drive everything'
author: 'Kodexa, Inc.'

branding:
  icon: 'refresh-cw'
  color: 'blue'

inputs:
  sync-config:
    description: 'Path to sync-config.yaml (auto-discovered if not specified)'
    required: false
    default: ''

  metadata-dir:
    description: 'Metadata directory override (auto-discovered if not specified)'
    required: false
    default: ''

  dry-run:
    description: 'Preview deployment without making changes (true/false)'
    required: false
    default: 'false'

  kdx-version:
    description: 'kdx-cli version to use (default: latest)'
    required: false
    default: 'latest'

  threads:
    description: 'Number of parallel threads for resource deployment (default: 8)'
    required: false
    default: '8'

  filter:
    description: 'Filter pattern for resources (e.g., "invoice-*")'
    required: false
    default: ''

  branch:
    description: 'Override branch detection with specific branch mapping'
    required: false
    default: ''

  tag:
    description: 'Override branch detection with specific tag mapping'
    required: false
    default: ''

  slack-channel-id:
    description: 'Slack channel ID to post deployment summary (optional)'
    required: false
    default: ''

  slack-token:
    description: 'Slack Bot Token for posting messages (optional)'
    required: false
    default: ''

  annotate-summary:
    description: 'Add deployment summary to GitHub Actions job summary (true/false)'
    required: false
    default: 'false'

outputs:
  targets-deployed:
    description: 'Number of targets deployed'
    value: ${{ steps.sync.outputs.targets }}

  resources-created:
    description: 'Number of resources created'
    value: ${{ steps.sync.outputs.resources_created }}

  resources-updated:
    description: 'Number of resources updated'
    value: ${{ steps.sync.outputs.resources_updated }}

  resources-skipped:
    description: 'Number of resources skipped (unchanged)'
    value: ${{ steps.sync.outputs.resources_skipped }}

  json-report:
    description: 'JSON deployment report (can be used in subsequent steps)'
    value: ${{ steps.sync.outputs.json_report }}

  json-report-path:
    description: 'Path to the JSON report file'
    value: ${{ steps.sync.outputs.json_report_path }}

runs:
  using: 'composite'
  steps:
    - name: Detect OS and Architecture
      id: detect
      shell: bash
      run: |
        OS=$(uname -s | tr '[:upper:]' '[:lower:]')
        ARCH=$(uname -m)

        # Normalize OS name
        case "$OS" in
          linux*)   OS="linux" ;;
          darwin*)  OS="darwin" ;;
          mingw*)   OS="windows" ;;
          msys*)    OS="windows" ;;
          cygwin*)  OS="windows" ;;
          *)        echo "‚ùå Unsupported OS: $OS"; exit 1 ;;
        esac

        # Normalize architecture
        case "$ARCH" in
          x86_64|amd64)   ARCH="x86_64" ;;
          aarch64|arm64)  ARCH="arm64" ;;
          *)              echo "‚ùå Unsupported architecture: $ARCH"; exit 1 ;;
        esac

        echo "os=$OS" >> $GITHUB_OUTPUT
        echo "arch=$ARCH" >> $GITHUB_OUTPUT
        echo "üìã Detected: $OS/$ARCH"

    - name: Determine kdx version
      id: version
      shell: bash
      run: |
        VERSION="${{ inputs.kdx-version }}"

        if [[ "$VERSION" == "latest" ]]; then
          echo "üîç Fetching latest kdx version..."
          LATEST=$(curl -s https://api.github.com/repos/kodexa-ai/kdx-cli-releases/releases/latest | grep '"tag_name"' | sed -E 's/.*"([^"]+)".*/\1/')
          if [[ -z "$LATEST" ]]; then
            echo "‚ùå Failed to fetch latest version"
            exit 1
          fi
          VERSION="$LATEST"
          echo "‚úÖ Latest version: $VERSION"
        fi

        echo "version=$VERSION" >> $GITHUB_OUTPUT

    - name: Cache kdx binary
      id: cache
      uses: actions/cache@v4
      with:
        path: ${{ runner.temp }}/kdx-bin
        key: kdx-${{ steps.version.outputs.version }}-${{ steps.detect.outputs.os }}-${{ steps.detect.outputs.arch }}

    - name: Download kdx binary
      if: steps.cache.outputs.cache-hit != 'true'
      shell: bash
      run: |
        VERSION="${{ steps.version.outputs.version }}"
        OS="${{ steps.detect.outputs.os }}"
        ARCH="${{ steps.detect.outputs.arch }}"

        # Construct download URL based on goreleaser naming
        if [[ "$OS" == "windows" ]]; then
          ARCHIVE="kdx_${VERSION#v}_${OS}_${ARCH}.zip"
          BINARY="kdx.exe"
        else
          ARCHIVE="kdx_${VERSION#v}_${OS}_${ARCH}.tar.gz"
          BINARY="kdx"
        fi

        DOWNLOAD_URL="https://github.com/kodexa-ai/kdx-cli-releases/releases/download/${VERSION}/${ARCHIVE}"

        echo "üì• Downloading kdx from: $DOWNLOAD_URL"

        mkdir -p "${{ runner.temp }}/kdx-download"
        cd "${{ runner.temp }}/kdx-download"

        if ! curl -sL -f "$DOWNLOAD_URL" -o "$ARCHIVE"; then
          echo "‚ùå Failed to download kdx from $DOWNLOAD_URL"
          echo "Available releases: https://github.com/kodexa-ai/kdx-cli-releases/releases"
          exit 1
        fi

        # Extract archive
        if [[ "$OS" == "windows" ]]; then
          unzip -q "$ARCHIVE"
        else
          tar -xzf "$ARCHIVE"
        fi

        # Move binary to cache location
        mkdir -p "${{ runner.temp }}/kdx-bin"
        mv "$BINARY" "${{ runner.temp }}/kdx-bin/"
        chmod +x "${{ runner.temp }}/kdx-bin/$BINARY"

        echo "‚úÖ Downloaded kdx $VERSION"

    - name: Add kdx to PATH
      shell: bash
      run: |
        echo "${{ runner.temp }}/kdx-bin" >> $GITHUB_PATH

    - name: Verify kdx installation
      shell: bash
      run: |
        kdx version

    - name: Run kdx sync deploy
      id: sync
      shell: bash
      run: |
        set -e

        # Generate JSON report path
        JSON_REPORT_PATH="${{ runner.temp }}/kdx-deploy-report.json"

        # Build command - simple and opinionated
        CMD="kdx sync deploy"

        # Add optional config path
        if [[ -n "${{ inputs.sync-config }}" ]]; then
          CMD="$CMD --config \"${{ inputs.sync-config }}\""
        fi

        # Add optional metadata directory
        if [[ -n "${{ inputs.metadata-dir }}" ]]; then
          CMD="$CMD --metadata-dir \"${{ inputs.metadata-dir }}\""
        fi

        # Add dry-run flag if requested
        if [[ "${{ inputs.dry-run }}" == "true" ]]; then
          CMD="$CMD --dry-run"
        fi

        # Add threads (default: 8 for parallel execution)
        THREADS="${{ inputs.threads }}"
        if [[ -n "$THREADS" && "$THREADS" != "0" ]]; then
          CMD="$CMD --threads $THREADS"
        fi

        # Add filter if specified
        if [[ -n "${{ inputs.filter }}" ]]; then
          CMD="$CMD --filter \"${{ inputs.filter }}\""
        fi

        # Add branch override if specified
        if [[ -n "${{ inputs.branch }}" ]]; then
          CMD="$CMD --branch \"${{ inputs.branch }}\""
        fi

        # Add tag override if specified
        if [[ -n "${{ inputs.tag }}" ]]; then
          CMD="$CMD --tag \"${{ inputs.tag }}\""
        fi

        # Always generate JSON report for structured output
        CMD="$CMD --json-report \"$JSON_REPORT_PATH\""

        echo "üöÄ Command: $CMD"

        # Run deployment - stream output in real-time AND capture for parsing
        # Using tee to both display and capture output
        set +e  # Don't exit on error yet
        OUTPUT=$(eval "$CMD" 2>&1 | tee /dev/stderr)
        EXIT_CODE=$?
        set -e

        if [[ $EXIT_CODE -ne 0 ]]; then
          echo ""
          echo "‚ùå Deployment failed with exit code $EXIT_CODE"
          if [[ -z "$OUTPUT" ]]; then
            echo "‚ö†Ô∏è  No output was produced by kdx. This may indicate:"
            echo "   - Missing or invalid API key environment variable"
            echo "   - Configuration file not found"
            echo "   - Invalid sync-config.yaml format"
          fi
          exit $EXIT_CODE
        fi

        # Parse output for statistics (best effort)
        # Match patterns like "Resources: 75 updated" or "project: 2 updated, 3 unchanged"
        # Use sed for portability (works on both GNU and BSD)
        UPDATED=$(echo "$OUTPUT" | sed -n 's/.*Resources:[[:space:]]*\([0-9]*\)[[:space:]]*updated/\1/p' | head -1)
        UPDATED=${UPDATED:-0}
        CREATED=$(echo "$OUTPUT" | sed -n 's/.*resources\?:[[:space:]]*\([0-9]*\)[[:space:]]*created.*/\1/p' | head -1)
        CREATED=${CREATED:-0}
        SKIPPED=$(echo "$OUTPUT" | sed -n 's/.*resources\?:[[:space:]]*\([0-9]*\)[[:space:]]*unchanged.*/\1/p' | head -1)
        SKIPPED=${SKIPPED:-0}
        # Count number of "Planned deployment" lines for targets
        TARGETS=$(echo "$OUTPUT" | grep -c "Planned deployment" || echo "0")

        echo "targets=$TARGETS" >> $GITHUB_OUTPUT
        echo "resources_created=$CREATED" >> $GITHUB_OUTPUT
        echo "resources_updated=$UPDATED" >> $GITHUB_OUTPUT
        echo "resources_skipped=$SKIPPED" >> $GITHUB_OUTPUT

        # Output JSON report path and content
        echo "json_report_path=$JSON_REPORT_PATH" >> $GITHUB_OUTPUT

        # Read and output JSON report if it exists (for use in subsequent steps)
        if [[ -f "$JSON_REPORT_PATH" ]]; then
          # Use EOF delimiter for multiline JSON
          echo "json_report<<EOF" >> $GITHUB_OUTPUT
          cat "$JSON_REPORT_PATH" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "üìä JSON report generated at: $JSON_REPORT_PATH"
        fi

        echo "‚úÖ Deployment completed successfully"

    - name: Generate GitHub Job Summary
      if: inputs.annotate-summary == 'true'
      shell: bash
      run: |
        CREATED="${{ steps.sync.outputs.resources_created }}"
        UPDATED="${{ steps.sync.outputs.resources_updated }}"
        SKIPPED="${{ steps.sync.outputs.resources_skipped }}"
        TARGETS="${{ steps.sync.outputs.targets }}"
        DRY_RUN="${{ inputs.dry-run }}"
        JSON_REPORT_PATH="${{ steps.sync.outputs.json_report_path }}"

        # Determine status emoji and text
        if [[ "$DRY_RUN" == "true" ]]; then
          STATUS_EMOJI="üîç"
          STATUS_TEXT="Dry Run Preview"
        else
          STATUS_EMOJI="üöÄ"
          STATUS_TEXT="Deployment Complete"
        fi

        # Calculate total
        TOTAL=$((CREATED + UPDATED + SKIPPED))

        # Write summary header
        cat >> $GITHUB_STEP_SUMMARY << EOF
        ## $STATUS_EMOJI Kodexa $STATUS_TEXT

        ### üìä Summary

        | Metric | Count |
        |--------|-------|
        | üÜï Created | $CREATED |
        | üîÑ Updated | $UPDATED |
        | ‚è≠Ô∏è Unchanged | $SKIPPED |
        | **Total** | **$TOTAL** |

        ### üìç Details

        | Property | Value |
        |----------|-------|
        | Repository | \`${{ github.repository }}\` |
        | Branch | \`${{ github.ref_name }}\` |
        | Commit | \`${{ github.sha }}\` |
        | Actor | @${{ github.actor }} |
        | Targets | $TARGETS |

        EOF

        # Add environment breakdown if JSON report exists and has target info
        if [[ -f "$JSON_REPORT_PATH" ]]; then
          # Try to extract environment info from JSON (if jq is available)
          if command -v jq &> /dev/null; then
            ENV_INFO=$(jq -r '.targets[]? | "| \(.environment // .name // "unknown") | \(.resources_updated // 0) updated, \(.resources_created // 0) created |"' "$JSON_REPORT_PATH" 2>/dev/null || echo "")
            if [[ -n "$ENV_INFO" ]]; then
              cat >> $GITHUB_STEP_SUMMARY << EOF

        ### üè¢ Environments

        | Environment | Resources |
        |-------------|-----------|
        $ENV_INFO

        EOF
            fi
          fi
        fi

        echo "üìã GitHub Job Summary generated"

    - name: Send Slack Notification
      if: inputs.slack-channel-id != '' && inputs.slack-token != ''
      shell: bash
      run: |
        CREATED="${{ steps.sync.outputs.resources_created }}"
        UPDATED="${{ steps.sync.outputs.resources_updated }}"
        SKIPPED="${{ steps.sync.outputs.resources_skipped }}"
        DRY_RUN="${{ inputs.dry-run }}"
        CHANNEL_ID="${{ inputs.slack-channel-id }}"
        SLACK_TOKEN="${{ inputs.slack-token }}"

        # Calculate total
        TOTAL=$((CREATED + UPDATED + SKIPPED))

        # Determine status
        if [[ "$DRY_RUN" == "true" ]]; then
          STATUS_EMOJI=":mag:"
          STATUS_TEXT="Dry Run Preview"
          COLOR="#3498db"
        else
          STATUS_EMOJI=":rocket:"
          STATUS_TEXT="Deployment Complete"
          COLOR="#2ecc71"
        fi

        # Build run URL
        RUN_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"

        # Create Slack Block Kit message
        SLACK_PAYLOAD=$(cat << EOFSLACK
        {
          "channel": "$CHANNEL_ID",
          "blocks": [
            {
              "type": "header",
              "text": {
                "type": "plain_text",
                "text": "$STATUS_EMOJI Kodexa $STATUS_TEXT",
                "emoji": true
              }
            },
            {
              "type": "section",
              "fields": [
                {
                  "type": "mrkdwn",
                  "text": "*Repository:*\n<${{ github.server_url }}/${{ github.repository }}|${{ github.repository }}>"
                },
                {
                  "type": "mrkdwn",
                  "text": "*Branch:*\n\`${{ github.ref_name }}\`"
                }
              ]
            },
            {
              "type": "section",
              "fields": [
                {
                  "type": "mrkdwn",
                  "text": "*:new: Created:*\n$CREATED"
                },
                {
                  "type": "mrkdwn",
                  "text": "*:arrows_counterclockwise: Updated:*\n$UPDATED"
                },
                {
                  "type": "mrkdwn",
                  "text": "*:next_track_button: Unchanged:*\n$SKIPPED"
                },
                {
                  "type": "mrkdwn",
                  "text": "*:bar_chart: Total:*\n$TOTAL"
                }
              ]
            },
            {
              "type": "context",
              "elements": [
                {
                  "type": "mrkdwn",
                  "text": "Triggered by *${{ github.actor }}* ‚Ä¢ <$RUN_URL|View Run #${{ github.run_number }}>"
                }
              ]
            }
          ],
          "attachments": [
            {
              "color": "$COLOR"
            }
          ]
        }
        EOFSLACK
        )

        # Send to Slack
        RESPONSE=$(curl -s -X POST "https://slack.com/api/chat.postMessage" \
          -H "Authorization: Bearer $SLACK_TOKEN" \
          -H "Content-Type: application/json" \
          -d "$SLACK_PAYLOAD")

        # Check response
        OK=$(echo "$RESPONSE" | grep -o '"ok":true' || echo "")
        if [[ -n "$OK" ]]; then
          echo "‚úÖ Slack notification sent successfully"
        else
          echo "‚ö†Ô∏è Slack notification may have failed. Response: $RESPONSE"
        fi
